// Copyright Titanium I.T. LLC.
"use strict";

const assert = require("util/assert");
const CommandLine = require("./command_line");
const testHelper = require("util/test_helper");
// dependency_analysis: ./_command_line_test_args_runner
// dependency_analysis: ./_command_line_test_null_output_runner
// dependency_analysis: ./_command_line_test_output_runner

describe.only("CommandLine", () => {

	it.skip("provides command-line arguments", async () => {
		/* CHALLENGE #1: Testing infrastructure
		 *
		 * Infrastructure can be tricky to test because it often involves complicated setup. In the case of the
		 * CommandLine infrastructure wrapper, the tests have run some of their code in a separate process, so they
		 * can control the child process's args, stdout, and stderr. I've simplified these challenges by providing
		 * the tests in advance.
		 *
		 * This is what this first test is doing (pseudocode):
		 *    // create process with the arguments "my arg 1" and "my arg 2"
		 *    const commandLine = CommandLine.create();
		 *    assert.deepEqual(commandLine.args(), [ "my arg 1", "my arg 2" ];
		 *
		 * Remove the ".skip" from this test and implement CommandLine.args().
		 *
		 * Hints:
		 *
		 * 1. In Node.js, process arguments are provided by the "process" global. Specifically, "process.argv", which
		 * returns an array.
		 *
		 * 2. The first two arguments of the "process.argv" arraay will be "node" and the name of the file being run.
		 * The real arguments come after that. You'll need to strip out the first two arguments. One way to do so is
		 * "process.argv.slice(2)".
		 *
		 */

		const args = [ "my arg 1", "my arg 2" ];
		const { stdout } = await testHelper.runModuleAsync(
			__dirname,
			"./_command_line_test_args_runner.js",
			{ args }
		);
		assert.equal(stdout, '["my arg 1","my arg 2"]');
	});

	it.skip("writes to stdout and stderr", async () => {
		/* CHALLENGE #2: More infrastructure tests
		 *
		 * This is very similar to the previous challenge.
		 *
		 * This is what this test is doing (pseudocode):
		 *    // in a separate process
		 *    const commandLine = CommandLine.create();
		 *    commandLine.writeStdout("my stdout");
		 *    commandLine.writeStderr("my stderr");
		 *    // in this process
		 *    const { stdout, stderr } = // results of running process
		 *    assert.equal(stdout, "my stdout");
		 *    assert.equal(stderr, "my stderr");
		 *
		 * Remove the ".skip" from this test and implement CommandLine.writeStdout() and .writeStderr().
		 *
		 * Hints:
		 *
		 * 1. To write to stdout, use "process.stdout.write(text)". Writing to stderr uses "process.stderr".
		 *
		 */

		const { stdout, stderr } = await testHelper.runModuleAsync(
			__dirname,
			"./_command_line_test_output_runner.js",
			{ failOnStderr: false }
		);
		assert.equal(stdout, "my stdout", "stdout");
		assert.equal(stderr, "my stderr", "stderr");
	});

	it.skip("tracks writes to stdout and stderr", () => {
		/* CHALLENGE #3: Tracking outputs
		 *
		 * Testing code that uses CommandLine is very cumbersome, as the previous tests show. We need a way to ask
		 * CommandLine what it has been written, rather than having to spawn a separate process.
		 *
		 * Remove the ".skip" from this test and implement CommandLine.trackStdout(). Then uncomment the commented-out
		 * lines in the test and implement CommandLine.trackStderr().
		 *
		 * After writing the production code, you'll see garbage showing up in the test results. Ignore it for this
		 * challenge.
		 *
		 * Hints:
		 *
		 * 1. I've provided a helper method for tracking output. To use it, you need an event emitter and the
		 * name of an event. Then you can use it like this:
		 *    trackStdout() {
		 *      return infrastructureHelper.trackOutput(this._emitter, STDOUT_EVENT);
		 *    }
		 *
		 * 2. To create the emitter, call "new EventEmitter()". EventEmitter is part of the Node.js standard library,
		 * and I've already required it.
		 *
		 * 3. To add data to the tracker, emit the event, like this:
		 *    this._emitter.emit(STDOUT_EVENT, "my data");
		 */

		const commandLine = CommandLine.create();
		const stdout = commandLine.trackStdout();
		// const stderr = commandLine.trackStderr();

		commandLine.writeStdout("my stdout");
		// commandLine.writeStderr("my stderr");
		assert.deepEqual(stdout, [ "my stdout" ]);
		// assert.deepEqual(stderr, [ "my stderr" ]);
	});


	describe("Nullability", () => {

		it.skip("doesn't write output to command line", async () => {
			/* CHALLENGE #4: Nullable output
			 *
			 * After finishing the previous challenge, you'll see garbage in the test output. That's because
			 * CommandLine.writeStdout() and .writeStderr() are writing test output to the command line. We need a
			 * way of preventing CommandLine from actually writing its output. You'll implement CommandLine.createNull()
			 * for this purpose.
			 *
			 * Although CommandLine.createNull() can be implemented with a flag and a bunch of "if" statements, the
			 * cleanest way to implement it is with a small stub of the "process" global.
			 *
			 * Remove the ".skip" from this test and implement CommandLine.createNull(), along with enough of a stub
			 * for the stdout assertion to pass. Then uncomment the second assertion in the test and expand the stub so
			 * the stderr assertion passes, too.
			 *
			 * After the test is working, update the test code for challenge #3 so it no longer writes to the command line.
			 *
			 * This is what this test is doing (pseudocode):
			 *    // in a separate process
			 *    const commandLine = CommandLine.create();
			 *    commandLine.writeStdout("this stdout should never be seen"");
			 *    commandLine.writeStderr("this stderr shouldn't be seen either");
			 *    // in this process
			 *    const { stdout, stderr } = // results of running process
			 *    assert.equal(stdout, "");
			 *    assert.equal(stderr, "");
			 *
			 * Hints:
			 *
			 * 1. Start by making "process" injectable. Pass the "process" global from create() into the constructor and
			 * store it in "this._process."
			 *
			 * 2. Modify writeStdout() to use "this._process" instead of the process global. Now you can control which
			 * code writeStdout() runs.
			 *
			 * 3. Remove the ".skip" from this test. It will complain createNull() is not a function. Implement it, but
			 * just duplicate create() for now. The test will fail, correctly showing that stdout is being written when
			 * it shouldn't be.
			 *
			 * 4. Now make an empty "NullProcess" class and have createNull() use an instance of that instead, like this:
			 *    return new CommandLine(new NullProcess());
			 * 
			 * 5. The code will fail because this._process.stdout is undefined. You need NullProcess to implement a
			 * stdout accessor that returns a do-nothing write() function, like this:
			 * 	  class NullProcess {
			 *      get stdout() {
			 *        return {
			 *          write() {}
			 *        };
			 *      }
			 *    }
			 *
			 * 7. Repeat for stderr.
			 *
			 * 8. To prevent the test in challenge #3 from writing to the command line, change "CommandLine.create()"
			 * in that test to "CommandLine.createNull()".
			 *
			 */

			const { stdout, stderr } = await testHelper.runModuleAsync(
				__dirname,
				"./_command_line_test_null_output_runner.js",
				{ failOnStderr: false }
			);
			assert.equal(stdout, "", "stdout");
			assert.equal(stderr, "", "stderr");
		});

		it.skip("defaults to no arguments", () => {
			/* CHALLENGE #5: Nullable args()
			 *
			 * If a test calls commandLine.args(), it will get whatever command line arguments were passed to the test
			 * runner. That will change depending on how the tests are run, which would result in unpredictable failures
			 * in the tests. Instead, we need CommandLine.args() to return the same results every time, no matter how
			 * the tests are run.
			 *
			 * Remove the ".skip" from this test and modify CommandLine.args() to always return an empty array when called
			 * on a null CommandLine.
			 *
			 * Hints:
			 *
			 * 1. You'll need to modify CommandLine.args() to use this._process rather than the process global.
			 *
			 * 2. You'll also need to expand the stub to provide an "argv" accessor, like this:
			 *    get argv() {
			 *      return [];
			 *    }
			 *
			 */

			const commandLine = CommandLine.createNull();
			assert.deepEqual(commandLine.args(), []);
		});

		it.skip("allows arguments to be configured", () => {
			/* CHALLENGE #6: Configurable args()
			 *
			 * Some tests will need to configure the response provided by commandLine.args(). Remove the ".skip" from this
			 * test and modify CommandLine.createNull() to support an optional "args" parameter.
			 *
			 * When the test passes, look for opportunities to refactor.
			 *
			 * Hints:
			 *
			 * 1. To take an optional parameter in CommandLine.createNull(), use object destructuring, like this:
			 *    static createNull({ args = [] } = {}) {
			 *
			 * (The above code says, "createNull() takes one parameter which defaults to an empty object. That empty
			 * object has a field named args, which defaults to an empty array if it isn't found.")
			 *
			 * 2. You'll need to store the arguments. Pass them to the NullProcess constructor and put them in an instance
			 * variable.
			 *
			 * 3. Return the arguments instance variable in NullProcess.argv, but remember that CommandLine.args() strips
			 * off the first two parameters, so you'll need to add two dummy parameters. I did it like this:
			 *    return [ "null_process_node", "null_process_script.js", ...this._args ];
			 *
			 */

			const commandLine = CommandLine.createNull({ args: [ "one", "two" ]});
			assert.deepEqual(commandLine.args(), [ "one", "two" ]);
		});

		/* CHALLENGE #7: Further investigation
		 *
		 * When you're done with the previous challenges, if there's still time remaining, take a look at the HttpServer
		 * infrastructure wrapper (in http/http_server.js). It's more complicated than CommandLine, but uses an embedded
		 * stub just like CommandLine. Look at the code and figure out how the stub works.
		 *
		 * If you still have additional time, look at the HttpClient wrapper (in http/http_client.js). It's the most
		 * complicated infrastructure wrapper, but it's implemented in the same way as CommandLine. Look at the
		 * trackRequests() method and compare it to CommandLine.trackStdout(). Then look at the stub code and compare
		 * it to the NullProcess stub in CommandLine.
		 *
		 * Finally, look at the Log (infrastructure/log.js) and then Rot13Client (www/infrastructure/rot13_client.js)
		 * infrastructure wrappers to see how higher-level infrastructure wrappers take advantage of lower-level wrappers
		 * in their createNull() factories.
		 */

	});

});


