// Copyright Titanium I.T. LLC.
"use strict";

const assert = require("util/assert");
const CommandLine = require("./command_line");
const testHelper = require("util/test_helper");
// dependency_analysis: ./_command_line_test_args_runner
// dependency_analysis: ./_command_line_test_null_output_runner
// dependency_analysis: ./_command_line_test_output_runner

describe.only("CommandLine", () => {

	it("provides command-line arguments", async () => {
		/* CHALLENGE #1: Testing infrastructure with narrow integration tests
		 *
		 * Infrastructure can be tricky to test because it often involves complicated setup. In the case of the
		 * CommandLine infrastructure wrapper, tests have to be run in a separate process. I've simplified the
		 * challenge by providing the tests already.
		 *
		 * This is what this test is doing (pseudocode):
		 *    const commandLine = CommandLine.create("my arg 1", "my arg 2");
		 *    assert.deepEqual(commandLine.args(), [ "my arg 1", "my arg 2" ];
		 *
		 * Remove the ".skip" from this test and implement CommandLine.args().
		 *
		 * Hints:
		 *
		 * 1. In Node.js, process arguments are provided by the "process" global. Specifically, in "process.argv".
		 *
		 * 2. The first two arguments will be the "node" and the name of the file. The real arguments come after that.
		 * You'll need to strip out the first two arguments. One way to do so is "process.argv.slice(2)".
		 *
		 */

		const args = [ "my arg 1", "my arg 2" ];
		const { stdout } = await testHelper.runModuleAsync(
			__dirname,
			"./_command_line_test_args_runner.js",
			{ args }
		);
		assert.equal(stdout, '["my arg 1","my arg 2"]');
	});

	it("writes to stdout and stderr", async () => {
		/* CHALLENGE #2: More infrastructure tests
		 *
		 * This is very similar to the previous challenge.
		 *
		 * This is what this test is doing (pseudocode):
		 *    const commandLine = CommandLine.create();
		 *    const stdout = commandLine.writeStdout("my stdout");
		 *    const stderr = commandLine.writeStderr("my stderr");
		 *    assert.equal(stdout, "my stdout");
		 *    assert.equal(stderr, "my stderr");
		 *
		 * Remove the ".skip" from this test and implement CommandLine.writeStdout() and .writeStderr().
		 *
		 * Hints:
		 *
		 * 1. To write to stdout, use "process.stdout.write(text)". Writing to stderr is similar.
		 *
		 */

		const { stdout, stderr } = await testHelper.runModuleAsync(
			__dirname,
			"./_command_line_test_output_runner.js",
			{ failOnStderr: false }
		);
		assert.equal(stdout, "my stdout", "stdout");
		assert.equal(stderr, "my stderr", "stderr");
	});

	it("tracks writes to stdout and stderr", () => {
		/* CHALLENGE #3: Tracking outputs
		 *
		 * Testing code that uses CommandLine is very cumbersome, as the previous tests show. We need a way to track
		 * CommandLine's output. That would allow us to simply ask CommandLine what it has been written, rather than
		 * having to spawn a separate process.
		 *
		 * Remove the ".skip" from this test and implement CommandLine.trackStdout(). Then uncomment the commented-out
		 * lines in the test and implement CommandLine.trackStderr().
		 *
		 * Don't worry about the extra test output for this challenge.
		 *
		 * Hints:
		 *
		 * 1. There's a helper method for tracking output already written. To use it, you need an event emitter and the
		 * name of an event. Then you can use it like this:
		 *    trackStdout() {
		 *      return infrastructureHelper.trackOutput(this._emitter, STDOUT_EVENT);
		 *    }
		 *
		 * 2. To create the emitter, call "new EventEmitter()".
		 *
		 * 3. To add data to the tracker, emit the event, like this:
		 *    this._emitter.emit(STDOUT_EVENT, "my data");
		 */

		const commandLine = CommandLine.create();
		const stdout = commandLine.trackStdout();
		// const stderr = commandLine.trackStderr();

		commandLine.writeStdout("my stdout");
		// commandLine.writeStderr("my stderr");
		assert.deepEqual(stdout, [ "my stdout" ]);
		// assert.deepEqual(stderr, [ "my stderr" ]);
	});


	describe("Nullability", () => {

		it("doesn't write output to command line", async () => {
			/* CHALLENGE #4: Nullable output
			 *
			 * After finishing the previous challenge, you'll see garbage in the test output. That's because
			 * CommandLine.writeStdout() and .writeStderr() are really writing their output to the command line. That
			 * can be a problem. We need a way of turning that off.
			 *
			 * First, refactor the production code to use this._process rather than the "process" global. (That will allow
			 * you to pass a different version of process later.) Then remove the ".skip" from this test and implement
			 * CommandLine.createNull() by using small stub for stdout.write(). Then uncomment the second assertion in
			 * the test and expand the stub for stderr.write().
			 *
			 * After the test is working, update the test code for challenge #3 so it no longer writes to the command line.
			 *
			 * Don't worry about commandLine.args() for this challenge.
			 *
			 * This is what this test is doing (pseudocode):
			 *    const commandLine = CommandLine.createNull();
			 *    const stdout = commandLine.writeStdout("my stdout");
			 *    const stderr = commandLine.writeStderr("my stderr");
			 *    assert.equal(stdout, "");
			 *    assert.equal(stderr, "");
			 *
			 * Hints:
			 *
			 * 1. Although this can be implemented with a flag and a bunch of "if" statements, the cleanest way to implement
			 * it is with an embedded stub. Specifically, a stubbed-out version of process.
			 *
			 * 2. Start by making "process" injectable. Pass the "process" global from create() into the
			 * constructor and store in "this._process", then modify every line that uses the "process" global to use
			 * "this._process" instead.
			 *
			 * 3. Remove the ".skip" from this test. It will complain createNull() is not a function. Implement it, but
			 * just pass the "process" global to the constructor for now. The test should fail.
			 *
			 * 4. Now make a "NullProcess" class and have createNull() use an instance of that instead, like this:
			 *    return new CommandLine(new NullProcess);
			 * 
			 * 5. The code will fail because this._process.stdout is undefined. You need to implement it, and a write()
			 * function. But they don't have to do anything.
			 * 
			 * 6. Like this:
			 * 	  class NullProcess {
			 *      get stdout() {
			 *        return {
			 *          write() {}
			 *        };
			 *      }
			 * }
			 *
			 * 7. Repeat for stderr.
			 *
			 * 8. To prevent the challenge #3 test from writing to the command line, change "CommandLine.create()" to
			 * "CommandLine.createNull()".
			 *
			 */

			const { stdout, stderr } = await testHelper.runModuleAsync(
				__dirname,
				"./_command_line_test_null_output_runner.js",
				{ failOnStderr: false }
			);
			assert.equal(stdout, "", "stdout");
			assert.equal(stderr, "", "stderr");
		});

		it.skip("defaults to no arguments", () => {
			const commandLine = CommandLine.createNull();
			assert.deepEqual(commandLine.args(), []);
		});

		it.skip("allows arguments to be configured", () => {
			const commandLine = CommandLine.createNull({ args: [ "one", "two" ]});
			assert.deepEqual(commandLine.args(), [ "one", "two" ]);
		});

	});

});


