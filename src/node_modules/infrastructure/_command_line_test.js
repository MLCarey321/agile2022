// Copyright Titanium I.T. LLC.
"use strict";

const assert = require("util/assert");
const CommandLine = require("./command_line");
const testHelper = require("util/test_helper");
// dependency_analysis: ./_command_line_test_args_runner
// dependency_analysis: ./_command_line_test_null_output_runner
// dependency_analysis: ./_command_line_test_output_runner

describe.only("CommandLine", () => {

	it("provides command-line arguments", async () => {
		/* CHALLENGE #1: Testing infrastructure with narrow integration tests
		 *
		 * Infrastructure can be tricky to test because it often involves complicated setup. In the case of the
		 * CommandLine infrastructure wrapper, tests have to be run in a separate process. I've simplified the
		 * challenge by providing the tests already.
		 *
		 * This is what this test is doing (pseudocode):
		 *    const commandLine = runProcess("my arg 1", "my arg 2");
		 *    assert.deepEqual(commandLine.args(), [ "my arg 1", "my arg 2" ];
		 *
		 * Remove the ".skip" from this test and implement CommandLine.args().
		 *
		 * Hints:
		 *
		 * 1. In Node.js, process arguments are provided by the "process" global. Specifically, in "process.argv".
		 *
		 * 2. The first two arguments will be the "node" and the name of the file. The real arguments come after that.
		 * You'll need to strip out the first two arguments. One way to do so is "process.argv.slice(2)".
		 *
		 */

		const args = [ "my arg 1", "my arg 2" ];
		const { stdout } = await testHelper.runModuleAsync(
			__dirname,
			"./_command_line_test_args_runner.js",
			{ args }
		);
		assert.equal(stdout, '["my arg 1","my arg 2"]');
	});

	it("writes to stdout and stderr", async () => {
		/* CHALLENGE #2: More infrastructure tests
		 *
		 * This is very similar to the previous challenge.
		 *
		 * This is what this test is doing (pseudocode):
		 *    const commandLine = runProcess();
		 *    const stdout = commandLine.writeStdout("my stdout");
		 *    const stderr = commandLine.writeStderr("my stderr");
		 *    assert.equal(stdout, "my stdout");
		 *    assert.equal(stderr, "my stderr");
		 *
		 * Remove the ".skip" from this test and implement CommandLine.writeStdout() and .writeStderr().
		 *
		 * Hints:
		 *
		 * 1. To write to stdout, use "process.stdout.write(text)". Writing to stderr is similar.
		 *
		 */

		const { stdout, stderr } = await testHelper.runModuleAsync(
			__dirname,
			"./_command_line_test_output_runner.js",
			{ failOnStderr: false }
		);
		assert.equal(stdout, "my stdout", "stdout");
		assert.equal(stderr, "my stderr", "stderr");
	});

	it("tracks writes to stdout and stderr", () => {
		/* CHALLENGE #3: Tracking outputs
		 *
		 * Testing code that uses CommandLine is very cumbersome, as the previous tests show. We need a way to track
		 * CommandLine's output. That would allow us to simply ask CommandLine what it has been written, rather than
		 * having to spawn a separate process.
		 *
		 * Remove the ".skip" from this test and implement CommandLine.trackStdout(). Then uncomment the commented-out
		 * lines in the test and implement CommandLine.trackStderr().
		 *
		 * Hints:
		 *
		 * 1. There's a helper method for tracking output already written. To use it, you need an event emitter and the
		 * name of an event. Then you can use it like this:
		 *    trackStdout() {
		 *      return infrastructureHelper.trackOutput(this._emitter, STDOUT_EVENT);
		 *    }
		 *
		 * 2. To create the emitter, call "new EventEmitter()".
		 *
		 * 3. To add data to the tracker, emit the event, like this:
		 *    this._emitter.emit(STDOUT_EVENT, "my data");
		 */

		const commandLine = CommandLine.create();
		const stdout = commandLine.trackStdout();
		// const stderr = commandLine.trackStderr();

		commandLine.writeStdout("my stdout");
		// commandLine.writeStderr("my stderr");
		assert.deepEqual(stdout, [ "my stdout" ]);
		// assert.deepEqual(stderr, [ "my stderr" ]);
	});


	describe("Nullability", () => {

		it.skip("doesn't write output to command line", async () => {
			const { stdout, stderr } = await testHelper.runModuleAsync(
				__dirname,
				"./_command_line_test_null_output_runner.js",
				{ failOnStderr: false }
			);
			assert.equal(stdout, "", "stdout");
			assert.equal(stderr, "", "stderr");
		});

		it.skip("defaults to no arguments", () => {
			const commandLine = CommandLine.createNull();
			assert.deepEqual(commandLine.args(), []);
		});

		it.skip("allows arguments to be configured", () => {
			const commandLine = CommandLine.createNull({ args: [ "one", "two" ]});
			assert.deepEqual(commandLine.args(), [ "one", "two" ]);
		});

	});

});


