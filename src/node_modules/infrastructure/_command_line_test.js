// Copyright Titanium I.T. LLC.
"use strict";

const assert = require("util/assert");
const CommandLine = require("./command_line");
const testHelper = require("util/test_helper");
// dependency_analysis: ./_command_line_test_args_runner
// dependency_analysis: ./_command_line_test_null_output_runner
// dependency_analysis: ./_command_line_test_output_runner

describe.only("CommandLine", () => {

	it.skip("provides command-line arguments", async () => {
		/* CHALLENGE #1: Testing infrastructure
		 *
		 * Infrastructure can be tricky to test because it often involves complicated setup. In the case of the
		 * CommandLine infrastructure wrapper, the tests have run some of their code in a separate process, so they
		 * can control the child process's args, stdout, and stderr. I've simplified these challenges by providing
		 * the tests in advance.
		 *
		 * For this challenge, remove the ".skip" from this test and implement CommandLine.args(). It should return the
		 * command-line arguments provided to the process.
		 *
		 * Useful methods:
		 * 1. const array = process.argv - an array with the command-line arguments. The first two arguments will be
		 * "node" and the name of the file being run. ("process" is a global that's built into Node.)
		 * 2. const newArray = array.slice(2) - remove the first two arguments of an array and return the result.
		 *
		 * Hints:
		 *
		 * 1. All you need to do is strip the first two arguments from process.argv and return the result:
		 *    return process.argv.slice(2);
		 *
		 */

		// This is what this test is doing (pseudocode):
		//    // create a separate process with the arguments "my arg 1" and "my arg 2"
		//    const commandLine = CommandLine.create();
		//    return commandLine.args();
		//
		//    // in this process
		//    const args = // result of other process
		//    assert.deepEqual(args, [ "my arg 1", "my arg 2" ];
		//
		const args = [ "my arg 1", "my arg 2" ];
		const { stdout } = await testHelper.runModuleAsync(
			__dirname,
			"./_command_line_test_args_runner.js",
			{ args }
		);
		assert.equal(stdout, '["my arg 1","my arg 2"]');
	});

	it.skip("writes to stdout and stderr", async () => {
		/* CHALLENGE #2: More infrastructure tests
		 *
		 * This is very similar to the previous challenge. Remove the ".skip" from this test and implement
		 * CommandLine.writeStdout(text) and .writeStderr(text). They should write "text" to stdout and stderr,
		 * respectively.
		 *
		 * Useful methods:
		 * 1. process.stdout.write(text) - write text to stdout
		 * 2. process.stderr.write(text) - write text to stderr
		 *
		 * Hints:
		 *
		 * 1. In writeStdout(), just call process.stdout:
		 *    process.stdout.write(text);
		 *
		 * 2. Similarly for writeStderr():
		 *    process.stderr.write(text);
		 *
		 */

		// This is what this test is doing (pseudocode):
		//    // in a separate process
		//    const commandLine = CommandLine.create();
		//    commandLine.writeStdout("my stdout");
		//    commandLine.writeStderr("my stderr");
		//
		//    // in this process
		//    const { stdout, stderr } = // results of running process
		//    assert.equal(stdout, "my stdout");
		//    assert.equal(stderr, "my stderr");
		//
		const { stdout, stderr } = await testHelper.runModuleAsync(
			__dirname,
			"./_command_line_test_output_runner.js",
			{ failOnStderr: false }
		);
		assert.equal(stdout, "my stdout", "stdout");
		assert.equal(stderr, "my stderr", "stderr");
	});

	it.skip("tracks writes to stdout and stderr", () => {
		/* CHALLENGE #3: Tracking outputs
		 *
		 * Testing code that uses CommandLine is very cumbersome, as the previous tests show. We need a way to ask
		 * CommandLine what it has been written, rather than having to spawn a separate process.
		 *
		 * Remove the ".skip" from this test and implement CommandLine.trackStdout(). Then uncomment the commented-out
		 * lines in the test and implement CommandLine.trackStderr(). Each should return an output tracker that works
		 * like rot13Request.trackRequests() and log.trackOutput() do (see exercise 1).
		 *
		 * After writing the production code, you'll see garbage showing up in the test results. Ignore it for this
		 * challenge.
		 *
		 * Useful methods:
		 * 1. const tracker = infrastructureHelper.trackOutput(emitter, eventName) - create an output tracker. It will
		 *      append any value that is emitted to the "emitter" event emitter for the "eventName" event.
		 * 2. const emitter = new EventEmitter() - create an event emitter. (Part of the Node.js standard library.)
		 * 3. emitter.emit(eventName, value) - emit an "eventName" event. "Value" can be of any type.
		 *
		 * Hints:
		 *
		 * 1. Create an event emitter in the constructor:
		 *    this._emitter = new EventEmitter();
		 *
		 * 2. Create a event name constant for stdout events:
		 *    const STDOUT_EVENT = "stdout";
		 *
		 * 3. Use infrastructureHelper.trackOutput() to implement trackStdout():
		 *    trackStdout() {
		 *      return infrastructureHelper.trackOutput(this._emitter, STDOUT_EVENT);
		 *    }
		 *
		 * 4. The test will fail with an empty array. That's because no events are being emitted.
		 *
		 * 5. Change writeStdout() to emit an event containing the output text:
		 *    this._emitter.emit(STDOUT_EVENT, text);
		 *
		 * 6. Uncomment the commented-out lines in the test and repeat for stderr.
		 *
		 */

		const commandLine = CommandLine.create();
		const stdout = commandLine.trackStdout();
		commandLine.writeStdout("my stdout");
		assert.deepEqual(stdout, [ "my stdout" ]);

		// const stderr = commandLine.trackStderr();
		// commandLine.writeStderr("my stderr");
		// assert.deepEqual(stderr, [ "my stderr" ]);
	});


	describe("Nullability", () => {

		it.skip("doesn't write output to command line", async () => {
			/* CHALLENGE #4: Nullable output
			 *
			 * After finishing the previous challenge, you'll see garbage in the test output. That's because
			 * CommandLine.writeStdout() and .writeStderr() are writing test output to the command line. We need a
			 * way of preventing CommandLine from actually writing its output. You'll implement CommandLine.createNull()
			 * for this purpose.
			 *
			 * Although CommandLine.createNull() can be implemented with a flag and a bunch of "if" statements, the
			 * cleanest way to implement it is with a small stub of the "process" global.
			 *
			 * Start by refactoring CommandLine.create() to inject the process global into the constructor. Then remove
			 * the ".skip" from this test and implement CommandLine.createNull(), along with enough of a stub of process
			 * for the stdout assertion to pass. Then uncomment the second assertion in the test and expand the stub so
			 * the stderr assertion passes, too.
			 *
			 * After the test is working, update the test code for challenge #3 so it no longer writes to the command line.
			 *
			 * JavaScript syntax notes:
			 *
			 * 1. Accessors
			 * To stub out process.stdout, you'll need to create an accessor: an object method that acts like a field.
			 * (In other words, it can be called without using parentheses.) To create an accessor in a class, use this
			 * syntax:
			 *    class MyClass {
			 *      get myAccessor() {
			 *        ...
			 *      }
			 *    }
			 *
			 * 2. Functions in objects
			 * To make an object that contains a function, without making a class, you can use this syntax:
			 *    const myObject = {
			 *      myFunction: function() { ... }
			 *    };
			 * You can also use this object function shorthand, which does the same thing:
			 *    const myObject = {
			 *      myFunction() { ... }
			 *    };
			 *
			 * Hints:
			 *
			 * 1. Don't remove the .skip from this test yet. Instead, start by making "process" injectable. Pass the
			 * "process" global from create() into the constructor and store it in "this._process".
			 *    static create() {
			 *      return new CommandLine(process);
			 *    }
			 *    constructor(proc) {
			 *      this._process = proc;
			 *      this._emitter = new EventEmitter();
			 *    }
			 *
			 * 2. Modify writeStdout() to use "this._process" instead of the process global. Now you can control which
			 * code writeStdout() runs. The tests should still pass.
			 *
			 * 3. Remove the ".skip" from this test. It will complain createNull() is not a function. Implement it, but
			 * just duplicate create() for now. The test will fail, correctly showing that stdout is being written when
			 * it shouldn't be.
			 *
			 * 4. Now make an empty "NullProcess" class at the bottom of the file:
			 *    class NullProcess {
			 *    }
			 *
			 * 5. Have createNull() pass an instance of the NullProcess class into the constructor, rather than passing
			 * the process global, like this:
			 *    return new CommandLine(new NullProcess());
			 * 
			 * 6. The test will fail because this._process.stdout is undefined. You need NullProcess to implement a
			 * stdout accessor that returns a do-nothing write() function, like this:
			 * 	  class NullProcess {
			 *      get stdout() {
			 *        return {
			 *          write() {}
			 *        };
			 *      }
			 *    }
			 *
			 * 7. Uncomment the second assertion and repeat for stderr.
			 *
			 * 8. To prevent the test in challenge #3 from writing to the command line, change "CommandLine.create()"
			 * in that test to "CommandLine.createNull()".
			 *
			 */

			// This is what this test is doing (pseudocode):
			//    // in a separate process
			//    const commandLine = CommandLine.createNull();
			//    commandLine.writeStdout("this stdout should never be seen");
			//    commandLine.writeStderr("this stderr shouldn't be seen either");
			//
			//    // in this process
			//    const { stdout, stderr } = // results of running process
			//    assert.equal(stdout, "");
			//    assert.equal(stderr, "");
			//
			const { stdout, stderr } = await testHelper.runModuleAsync(
				__dirname,
				"./_command_line_test_null_output_runner.js",
				{ failOnStderr: false }
			);
			assert.equal(stdout, "", "stdout");
			// assert.equal(stderr, "", "stderr");
		});

		it.skip("defaults to no arguments", () => {
			/* CHALLENGE #5: Nullable args()
			 *
			 * If a test calls commandLine.args(), it will get whatever command line arguments were provided to the
			 * build script. That will result in surprising test failures when different people run the build script
			 * in different ways. We need CommandLine.args() to return the same results every time, no matter how
			 * the tests are run.
			 *
			 * Remove the ".skip" from this test and modify CommandLine.args() to always return an empty array when called
			 * on a null CommandLine.
			 *
			 * Hints:
			 *
			 * 1. When you first run this test, it will probably complain that it got [ "quick" ] rather than an empty
			 * array. That’s because it’s reading the "watch quick" command line. It's doing so because it's
			 * calling "process.argv" on the process global.
			 *
			 * 2. You'll need to modify CommandLine.args() to use this._process rather than the process global.
			 *
			 * 3. When you do, the tests will fail, complaining that "slice()" is being called on an undefined variable.
			 * That’s because process.argv is undefined.
			 *
			 * 4. To fix the problem, you need to expand the NullProcess stub to provide an "argv" accessor, like this:
			 *    get argv() {
			 *      return [];
			 *    }
			 *
			 */

			const commandLine = CommandLine.createNull();
			assert.deepEqual(commandLine.args(), []);
		});

		it.skip("allows arguments to be configured", () => {
			/* CHALLENGE #6: Configurable args()
			 *
			 * Some tests will need to configure the response provided by commandLine.args(). Remove the ".skip" from this
			 * test and modify CommandLine.createNull() to support an optional "args" parameter.
			 *
			 * When the test passes, look for opportunities to refactor.
			 *
			 * JavaScript syntax notes:
			 *
			 * 1. Default parameters.
			 * To take an optional "args" parameter that defaults to an empty array in CommandLine.createNull(), use
			 * object destructuring and default parameters together, like this:
       *    static createNull({ args = [] } = {}) { ... }
			 * This code says, "createNull() takes one parameter which defaults to an empty object. That empty
			 * object has a field named args, which we'll turn into a variable. If it doesn't exist, default it to
			 * an empty array."
			 *
			 * 2. Spread operator.
			 * You can insert the contents of an array into another array using the "..." (spread) operator. For example,
			 * the following code will output "1, 2, 3, 4, 5"
			 *    const myArray = [ 3, 4, 5 ];
			 *    const newArray = [ 1, 2, ...myArray ];
			 *    console.log(newArray);
			 *
			 * Hints:
			 *
			 * 1. Modify createNull() to take an optional "args" parameter that defaults to an empty array, like this:
			 *    static createNull({ args = [] } = {}) {
			 *
			 * 2. You'll need to store the arguments. Pass them to the NullProcess constructor and put them in an instance
			 * variable, like this:
			 *    static createNull({ args = [] } = {} {
			 *      return new CommandLine(new NullProcess(args));
			 *    }
			 *
			 *    // in the NullProcess class:
			 *    constructor(args) {
			 *      this._args = args;
			 *    }
			 *
			 * 3. Return the arguments instance variable in NullProcess.argv, but remember that CommandLine.args() strips
			 * off the first two parameters, so you'll need to add two dummy parameters. Like this:
			 *    get argv() {
			 *      return [ "null_process_node", "null_process_script.js", ...this._args ];
			 *    }
			 *
			 */

			const commandLine = CommandLine.createNull({ args: [ "one", "two" ]});
			assert.deepEqual(commandLine.args(), [ "one", "two" ]);
		});

		/* CHALLENGE #7: Further investigation
		 *
		 * When you're done with the previous challenges, look at the Log (infrastructure/log.js) and then Rot13Client
		 * (www/infrastructure/rot13_client.js) infrastructure wrappers to see how higher-level infrastructure wrappers
		 * take advantage of lower-level wrappers in their createNull() factories.
		 * 
		 * If there's still time remaining, take a look at the HttpServer infrastructure wrapper (in http/http_server.js).
		 * It's more complicated than CommandLine, but uses an embedded stub just like CommandLine. Look at the code and
		 * figure out how the stub works.
		 *
		 * If you still have additional time, look at the HttpClient wrapper (in http/http_client.js). It's the most
		 * complicated infrastructure wrapper, but it's implemented in the same way as CommandLine. Look at the
		 * trackRequests() method and compare it to CommandLine.trackStdout(). Then look at the stub code and compare
		 * it to the NullProcess stub in CommandLine.
		 *
		 */

	});

});


